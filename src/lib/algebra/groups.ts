/**
 * Group implementations for common groups
 */

import type { Group, DihedralElement, CayleyTableCell } from '../types/algebra';
import { mod, gcd } from '../utils/math';

/**
 * Create the cyclic group Z_n (integers mod n under addition)
 */
export function createZn(n: number): Group<number> {
  if (n < 1) throw new Error('n must be positive');

  const elements = Array.from({ length: n }, (_, i) => i);

  return {
    name: `Z_${n}`,
    elements,
    identity: 0,
    operation: (a, b) => mod(a + b, n),
    inverse: (a) => mod(-a, n),
    equals: (a, b) => mod(a, n) === mod(b, n),
    toString: (a) => String(mod(a, n)),
  };
}

/**
 * Create the multiplicative group Z_n^* (units mod n under multiplication)
 */
export function createZnStar(n: number): Group<number> {
  if (n < 2) throw new Error('n must be at least 2');

  // Elements are integers k where 1 ≤ k < n and gcd(k, n) = 1
  const elements: number[] = [];
  for (let k = 1; k < n; k++) {
    if (gcd(k, n) === 1) {
      elements.push(k);
    }
  }

  // Find modular inverse using extended Euclidean algorithm
  const findInverse = (a: number): number => {
    for (const e of elements) {
      if (mod(a * e, n) === 1) return e;
    }
    throw new Error(`No inverse found for ${a} mod ${n}`);
  };

  return {
    name: `Z_${n}^*`,
    elements,
    identity: 1,
    operation: (a, b) => mod(a * b, n),
    inverse: findInverse,
    equals: (a, b) => mod(a, n) === mod(b, n),
    toString: (a) => String(mod(a, n)),
  };
}

/**
 * Create the dihedral group D_n (symmetries of regular n-gon)
 * Elements are represented as { rotation: k, isReflection: boolean }
 * where rotation r rotates by 2π/n counterclockwise
 * and s is reflection across the axis through vertex 0
 *
 * Relations: r^n = e, s^2 = e, srs = r^(-1)
 */
export function createDn(n: number): Group<DihedralElement> {
  if (n < 3) throw new Error('n must be at least 3');

  const elements: DihedralElement[] = [];

  // Rotations: e, r, r^2, ..., r^(n-1)
  for (let k = 0; k < n; k++) {
    elements.push({ rotation: k, isReflection: false });
  }

  // Reflections: s, sr, sr^2, ..., sr^(n-1)
  for (let k = 0; k < n; k++) {
    elements.push({ rotation: k, isReflection: true });
  }

  const identity: DihedralElement = { rotation: 0, isReflection: false };

  // Operation: compose two symmetries
  // r^a * r^b = r^(a+b)
  // s * r^a = sr^a (reflection)
  // r^a * s = sr^(-a) = sr^(n-a)
  // sr^a * r^b = sr^(a+b)
  // sr^a * sr^b = r^(a-b) (using srs = r^(-1))
  const operation = (a: DihedralElement, b: DihedralElement): DihedralElement => {
    if (!a.isReflection && !b.isReflection) {
      // r^a * r^b = r^(a+b)
      return { rotation: mod(a.rotation + b.rotation, n), isReflection: false };
    } else if (!a.isReflection && b.isReflection) {
      // r^a * sr^b = sr^(b-a)
      return { rotation: mod(b.rotation - a.rotation, n), isReflection: true };
    } else if (a.isReflection && !b.isReflection) {
      // sr^a * r^b = sr^(a+b)
      return { rotation: mod(a.rotation + b.rotation, n), isReflection: true };
    } else {
      // sr^a * sr^b = r^(a-b)
      return { rotation: mod(a.rotation - b.rotation, n), isReflection: false };
    }
  };

  const inverse = (a: DihedralElement): DihedralElement => {
    if (!a.isReflection) {
      // (r^k)^(-1) = r^(-k) = r^(n-k)
      return { rotation: mod(-a.rotation, n), isReflection: false };
    } else {
      // (sr^k)^(-1) = sr^k (reflections are self-inverse)
      return { ...a };
    }
  };

  const equals = (a: DihedralElement, b: DihedralElement): boolean => {
    return a.rotation === b.rotation && a.isReflection === b.isReflection;
  };

  const toString = (a: DihedralElement): string => {
    if (!a.isReflection) {
      if (a.rotation === 0) return 'e';
      if (a.rotation === 1) return 'r';
      return `r^${a.rotation}`;
    } else {
      if (a.rotation === 0) return 's';
      if (a.rotation === 1) return 'sr';
      return `sr^${a.rotation}`;
    }
  };

  return {
    name: `D_${n}`,
    elements,
    identity,
    operation,
    inverse,
    equals,
    toString,
  };
}

/**
 * Get the order of an element in a group
 */
export function elementOrder<T>(group: Group<T>, element: T): number {
  let current = element;
  let order = 1;

  while (!group.equals(current, group.identity)) {
    current = group.operation(current, element);
    order++;

    if (order > group.elements.length) {
      throw new Error('Element order exceeds group size - invalid group');
    }
  }

  return order;
}

/**
 * Generate the subgroup generated by a set of elements
 */
export function generateSubgroup<T>(group: Group<T>, generators: T[]): T[] {
  const subgroup = new Set<string>();
  const elements: T[] = [];

  const addElement = (elem: T) => {
    const key = group.toString(elem);
    if (!subgroup.has(key)) {
      subgroup.add(key);
      elements.push(elem);
    }
  };

  // Start with identity
  addElement(group.identity);

  // Add generators and their inverses
  for (const g of generators) {
    addElement(g);
    addElement(group.inverse(g));
  }

  // Close under the operation
  let changed = true;
  while (changed) {
    changed = false;
    for (const a of [...elements]) {
      for (const b of [...elements]) {
        const product = group.operation(a, b);
        const key = group.toString(product);
        if (!subgroup.has(key)) {
          addElement(product);
          changed = true;
        }
      }
    }
  }

  return elements;
}

/**
 * Check if a subset is a subgroup
 */
export function isSubgroup<T>(group: Group<T>, subset: T[]): boolean {
  // Must contain identity
  if (!subset.some((e) => group.equals(e, group.identity))) {
    return false;
  }

  // Must be closed under operation and inverse
  for (const a of subset) {
    // Check inverse
    const inv = group.inverse(a);
    if (!subset.some((e) => group.equals(e, inv))) {
      return false;
    }

    // Check closure
    for (const b of subset) {
      const product = group.operation(a, b);
      if (!subset.some((e) => group.equals(e, product))) {
        return false;
      }
    }
  }

  return true;
}

/**
 * Generate the Cayley table for a group
 */
export function cayleyTable<T>(group: Group<T>): CayleyTableCell<T>[][] {
  const table: CayleyTableCell<T>[][] = [];

  for (let i = 0; i < group.elements.length; i++) {
    const row: CayleyTableCell<T>[] = [];
    for (let j = 0; j < group.elements.length; j++) {
      const a = group.elements[i];
      const b = group.elements[j];
      row.push({
        row: a,
        col: b,
        result: group.operation(a, b),
        rowIndex: i,
        colIndex: j,
      });
    }
    table.push(row);
  }

  return table;
}

/**
 * Check if a group is abelian (commutative)
 */
export function isAbelian<T>(group: Group<T>): boolean {
  for (const a of group.elements) {
    for (const b of group.elements) {
      const ab = group.operation(a, b);
      const ba = group.operation(b, a);
      if (!group.equals(ab, ba)) {
        return false;
      }
    }
  }
  return true;
}

/**
 * Check if a group is cyclic
 */
export function isCyclic<T>(group: Group<T>): { isCyclic: boolean; generators: T[] } {
  const generators: T[] = [];

  for (const g of group.elements) {
    const order = elementOrder(group, g);
    if (order === group.elements.length) {
      generators.push(g);
    }
  }

  return {
    isCyclic: generators.length > 0,
    generators,
  };
}

/**
 * Get the center of a group Z(G) = { g ∈ G : gx = xg for all x ∈ G }
 */
export function center<T>(group: Group<T>): T[] {
  return group.elements.filter((g) =>
    group.elements.every((x) =>
      group.equals(group.operation(g, x), group.operation(x, g))
    )
  );
}

/**
 * Compute left cosets of a subgroup
 */
export function leftCosets<T>(group: Group<T>, subgroup: T[]): T[][] {
  const cosets: T[][] = [];
  const seen = new Set<string>();

  for (const g of group.elements) {
    // Compute gH
    const coset = subgroup.map((h) => group.operation(g, h));
    const cosetKey = coset
      .map((e) => group.toString(e))
      .sort()
      .join(',');

    if (!seen.has(cosetKey)) {
      seen.add(cosetKey);
      cosets.push(coset);
    }
  }

  return cosets;
}

/**
 * Check if a subgroup is normal
 * H is normal in G iff gHg^(-1) = H for all g in G
 */
export function isNormalSubgroup<T>(group: Group<T>, subgroup: T[]): boolean {
  const subgroupSet = new Set(subgroup.map((e) => group.toString(e)));

  for (const g of group.elements) {
    const gInv = group.inverse(g);
    for (const h of subgroup) {
      const conjugate = group.operation(group.operation(g, h), gInv);
      if (!subgroupSet.has(group.toString(conjugate))) {
        return false;
      }
    }
  }

  return true;
}
