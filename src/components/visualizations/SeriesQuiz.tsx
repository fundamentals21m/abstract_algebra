import { useState } from 'react';

type Difficulty = 'easy' | 'medium' | 'hard';

interface MultipleChoiceQuestion {
  type: string;
  responseType: 'multiple_choice';
  question: string;
  options: string[];
  correctIndex: number;
  explanation: string;
}

interface FreeResponseQuestion {
  type: string;
  responseType: 'free_response';
  question: string;
  correctAnswer: string;
  acceptedAnswers: string[];
  explanation: string;
}

type Question = MultipleChoiceQuestion | FreeResponseQuestion;

function randomChoice<T>(array: T[]): T {
  return array[Math.floor(Math.random() * array.length)];
}

// Subnormal series definition
function generateSubnormalQuestion(difficulty: Difficulty): MultipleChoiceQuestion {
  const scenarios = difficulty === 'easy' ? [
    {
      statement: 'In a subnormal series, each term is normal in the next term',
      correct: true,
      why: 'A subnormal series is {e} = G₀ ⊴ G₁ ⊴ ... ⊴ Gₙ = G'
    },
    {
      statement: 'In a subnormal series, each term must be normal in G',
      correct: false,
      why: 'False: terms only need to be normal in the next term, not in G'
    },
  ] : difficulty === 'medium' ? [
    {
      statement: 'Every normal series is a subnormal series',
      correct: true,
      why: 'Normal series require Gᵢ ⊴ G, which implies Gᵢ ⊴ Gᵢ₊₁'
    },
    {
      statement: 'Every subnormal series is a normal series',
      correct: false,
      why: 'False: subnormal only requires Gᵢ ⊴ Gᵢ₊₁, not Gᵢ ⊴ G'
    },
  ] : [
    {
      statement: 'The factors of a subnormal series are the quotients Gᵢ₊₁/Gᵢ',
      correct: true,
      why: 'These quotient groups (factors) characterize the series'
    },
  ];

  const scenario = randomChoice(scenarios);
  return {
    type: 'subnormal',
    responseType: 'multiple_choice',
    question: `True or False: ${scenario.statement}`,
    options: ['True', 'False'],
    correctIndex: scenario.correct ? 0 : 1,
    explanation: scenario.why
  };
}

// Composition series
function generateCompositionQuestion(difficulty: Difficulty): MultipleChoiceQuestion {
  const scenarios = difficulty === 'easy' ? [
    {
      statement: 'A composition series has simple factors (non-trivial with no proper normal subgroups)',
      correct: true,
      why: 'Each factor Gᵢ₊₁/Gᵢ must be simple in a composition series'
    },
  ] : difficulty === 'medium' ? [
    {
      statement: 'ℤ₆ has composition series {0} ⊴ ⟨3⟩ ⊴ ℤ₆ with factors ℤ₃ and ℤ₂',
      correct: true,
      why: 'Factors: ⟨3⟩/{0} ≅ ℤ₂ and ℤ₆/⟨3⟩ ≅ ℤ₃, both simple (prime order)'
    },
    {
      statement: 'S₃ has a composition series with factor A₃ ≅ ℤ₃',
      correct: true,
      why: '{e} ⊴ A₃ ⊴ S₃ gives factors ℤ₃ and ℤ₂'
    },
  ] : [
    {
      statement: 'A₅ has no proper composition series (only {e} ⊴ A₅)',
      correct: true,
      why: 'A₅ is simple, so the only composition series is {e} ⊴ A₅'
    },
    {
      statement: 'The composition factors of a finite group are unique up to order',
      correct: true,
      why: 'This is the Jordan-Hölder Theorem'
    },
  ];

  const scenario = randomChoice(scenarios);
  return {
    type: 'composition',
    responseType: 'multiple_choice',
    question: `True or False: ${scenario.statement}`,
    options: ['True', 'False'],
    correctIndex: scenario.correct ? 0 : 1,
    explanation: scenario.why
  };
}

// Solvable groups
function generateSolvableQuestion(difficulty: Difficulty): MultipleChoiceQuestion {
  const scenarios = difficulty === 'easy' ? [
    { group: 'ℤₙ', solvable: true, why: 'All abelian groups are solvable (derived series terminates at {e})' },
    { group: 'S₃', solvable: true, why: 'S₃ ⊵ A₃ ⊵ {e} with abelian factors ℤ₂ and ℤ₃' },
  ] : difficulty === 'medium' ? [
    { group: 'S₄', solvable: true, why: 'S₄ ⊵ A₄ ⊵ V₄ ⊵ ⟨(12)(34)⟩ ⊵ {e}' },
    { group: 'D₅', solvable: true, why: 'D₅ ⊵ ⟨r⟩ ⊵ {e} with abelian factors' },
  ] : [
    { group: 'S₅', solvable: false, why: 'A₅ is simple non-abelian, so derived series never terminates' },
    { group: 'A₅', solvable: false, why: 'Simple non-abelian groups are not solvable' },
    { group: 'Sₙ (n ≥ 5)', solvable: false, why: 'Contains simple non-abelian subgroup Aₙ' },
  ];

  const scenario = randomChoice(scenarios);
  return {
    type: 'solvable',
    responseType: 'multiple_choice',
    question: `Is ${scenario.group} solvable?`,
    options: ['Yes', 'No'],
    correctIndex: scenario.solvable ? 0 : 1,
    explanation: scenario.solvable ? `Yes: ${scenario.why}.` : `No: ${scenario.why}.`
  };
}

// Derived series
function generateDerivedQuestion(difficulty: Difficulty): MultipleChoiceQuestion {
  const scenarios = difficulty === 'easy' ? [
    {
      statement: 'G\' = [G,G] is the subgroup generated by all commutators',
      correct: true,
      why: 'G\' = ⟨[a,b] : a,b ∈ G⟩ where [a,b] = aba⁻¹b⁻¹'
    },
    {
      statement: 'G\' is always abelian',
      correct: false,
      why: 'False: G\' can be non-abelian (e.g., (S₄)\' = A₄ is non-abelian)'
    },
  ] : difficulty === 'medium' ? [
    {
      statement: 'G/G\' is always abelian',
      correct: true,
      why: 'G\' contains all commutators, so G/G\' has trivial commutator subgroup'
    },
    {
      statement: 'If G is abelian, then G\' = {e}',
      correct: true,
      why: '[a,b] = aba⁻¹b⁻¹ = e for all a,b in an abelian group'
    },
  ] : [
    {
      statement: 'G is solvable iff the derived series reaches {e}',
      correct: true,
      why: 'G ⊵ G\' ⊵ G\'\' ⊵ ... must terminate at {e}'
    },
    {
      statement: '(Sₙ)\' = Aₙ for n ≥ 2',
      correct: true,
      why: 'The commutator subgroup of Sₙ is the alternating group'
    },
  ];

  const scenario = randomChoice(scenarios);
  return {
    type: 'derived',
    responseType: 'multiple_choice',
    question: `True or False: ${scenario.statement}`,
    options: ['True', 'False'],
    correctIndex: scenario.correct ? 0 : 1,
    explanation: scenario.why
  };
}

// Jordan-Hölder Theorem
function generateJordanHolderQuestion(_difficulty: Difficulty): MultipleChoiceQuestion {
  const scenarios = [
    {
      statement: 'Any two composition series of a finite group have the same length',
      correct: true,
      why: 'Jordan-Hölder Theorem guarantees this'
    },
    {
      statement: 'The composition factors of any two composition series are the same (up to reordering)',
      correct: true,
      why: 'This is the main content of the Jordan-Hölder Theorem'
    },
    {
      statement: 'Every finite group has a unique composition series',
      correct: false,
      why: 'False: the series may not be unique, but the factors are (up to order)'
    },
  ];

  const scenario = randomChoice(scenarios);
  return {
    type: 'jordan_holder',
    responseType: 'multiple_choice',
    question: `True or False: ${scenario.statement}`,
    options: ['True', 'False'],
    correctIndex: scenario.correct ? 0 : 1,
    explanation: scenario.why
  };
}

// Nilpotent groups
function generateNilpotentQuestion(difficulty: Difficulty): MultipleChoiceQuestion {
  const scenarios = difficulty === 'easy' ? [
    { group: 'any abelian group', nilpotent: true, why: 'abelian groups have nilpotency class 1' },
    { group: 'S₃', nilpotent: false, why: 'center is trivial, upper central series doesn\'t reach G' },
  ] : difficulty === 'medium' ? [
    { group: 'any p-group', nilpotent: true, why: 'p-groups have nontrivial center, always nilpotent' },
    { group: 'Dₙ (n odd > 1)', nilpotent: false, why: 'center is trivial for odd n' },
  ] : [
    { group: 'D₄', nilpotent: true, why: 'Z(D₄) = ⟨r²⟩ ≠ {e}, and D₄/Z(D₄) ≅ V₄ is abelian' },
    { group: 'direct product of nilpotent groups', nilpotent: true, why: 'nilpotency is preserved under direct products' },
  ];

  const scenario = randomChoice(scenarios);
  return {
    type: 'nilpotent',
    responseType: 'multiple_choice',
    question: `Is ${scenario.group} nilpotent?`,
    options: ['Yes', 'No'],
    correctIndex: scenario.nilpotent ? 0 : 1,
    explanation: scenario.nilpotent ? `Yes: ${scenario.why}.` : `No: ${scenario.why}.`
  };
}

function generateQuestion(difficulty: Difficulty): Question {
  const generators = [
    generateSubnormalQuestion,
    generateCompositionQuestion,
    generateSolvableQuestion,
    generateDerivedQuestion,
    generateJordanHolderQuestion,
    generateNilpotentQuestion,
  ];

  return randomChoice(generators)(difficulty);
}

function generateQuiz(difficulty: Difficulty): Question[] {
  const questions: Question[] = [];
  const usedTypes = new Set<string>();

  while (questions.length < 5) {
    const question = generateQuestion(difficulty);
    if (!usedTypes.has(question.type)) {
      usedTypes.add(question.type);
      questions.push(question);
    }
  }

  return questions;
}

export function SeriesQuiz() {
  const [difficulty, setDifficulty] = useState<Difficulty | null>(null);
  const [questions, setQuestions] = useState<Question[]>([]);
  const [currentQuestion, setCurrentQuestion] = useState(0);
  const [selectedAnswer, setSelectedAnswer] = useState<number | null>(null);
  const [textAnswer, setTextAnswer] = useState('');
  const [showResult, setShowResult] = useState(false);
  const [score, setScore] = useState(0);
  const [quizComplete, setQuizComplete] = useState(false);

  const startQuiz = (diff: Difficulty) => {
    setDifficulty(diff);
    setQuestions(generateQuiz(diff));
    setCurrentQuestion(0);
    setSelectedAnswer(null);
    setTextAnswer('');
    setShowResult(false);
    setScore(0);
    setQuizComplete(false);
  };

  const checkAnswer = () => {
    const question = questions[currentQuestion];
    let isCorrect = false;

    if (question.responseType === 'multiple_choice') {
      isCorrect = selectedAnswer === question.correctIndex;
    } else {
      const normalizedAnswer = textAnswer.trim().toLowerCase();
      isCorrect = question.acceptedAnswers.some(
        ans => ans.toLowerCase() === normalizedAnswer
      );
    }

    if (isCorrect) setScore(score + 1);
    setShowResult(true);
  };

  const nextQuestion = () => {
    if (currentQuestion + 1 >= questions.length) {
      setQuizComplete(true);
    } else {
      setCurrentQuestion(currentQuestion + 1);
      setSelectedAnswer(null);
      setTextAnswer('');
      setShowResult(false);
    }
  };

  if (!difficulty) {
    return (
      <div className="my-8 p-6 bg-gray-900 rounded-xl border border-purple-500/30">
        <h3 className="text-xl font-bold text-purple-300 mb-4">Series of Groups Quiz</h3>
        <p className="text-gray-300 mb-4">Test your understanding of normal series, composition series, and solvability!</p>
        <div className="flex gap-4 flex-wrap">
          {(['easy', 'medium', 'hard'] as Difficulty[]).map((diff) => (
            <button
              key={diff}
              onClick={() => startQuiz(diff)}
              className={`px-6 py-2 rounded-lg font-medium transition-all ${
                diff === 'easy' ? 'bg-green-600 hover:bg-green-500' :
                diff === 'medium' ? 'bg-yellow-600 hover:bg-yellow-500' :
                'bg-red-600 hover:bg-red-500'
              }`}
            >
              {diff.charAt(0).toUpperCase() + diff.slice(1)}
            </button>
          ))}
        </div>
      </div>
    );
  }

  if (quizComplete) {
    return (
      <div className="my-8 p-6 bg-gray-900 rounded-xl border border-purple-500/30">
        <h3 className="text-xl font-bold text-purple-300 mb-4">Quiz Complete!</h3>
        <p className="text-2xl text-white mb-4">
          Score: {score}/{questions.length} ({Math.round(score/questions.length * 100)}%)
        </p>
        <button
          onClick={() => setDifficulty(null)}
          className="px-6 py-2 bg-purple-600 hover:bg-purple-500 rounded-lg font-medium transition-all"
        >
          Try Again
        </button>
      </div>
    );
  }

  const question = questions[currentQuestion];

  return (
    <div className="my-8 p-6 bg-gray-900 rounded-xl border border-purple-500/30">
      <div className="flex justify-between items-center mb-4">
        <h3 className="text-lg font-bold text-purple-300">
          Question {currentQuestion + 1}/{questions.length}
        </h3>
        <span className="text-gray-400 capitalize">{difficulty}</span>
      </div>

      <p className="text-white text-lg mb-6">{question.question}</p>

      {question.responseType === 'multiple_choice' ? (
        <div className="space-y-3">
          {question.options.map((option, index) => (
            <button
              key={index}
              onClick={() => !showResult && setSelectedAnswer(index)}
              disabled={showResult}
              className={`w-full text-left p-4 rounded-lg border transition-all ${
                showResult
                  ? index === question.correctIndex
                    ? 'bg-green-600/30 border-green-500'
                    : index === selectedAnswer
                    ? 'bg-red-600/30 border-red-500'
                    : 'bg-gray-800 border-gray-600'
                  : selectedAnswer === index
                  ? 'bg-purple-600/30 border-purple-500'
                  : 'bg-gray-800 border-gray-600 hover:border-purple-500'
              }`}
            >
              {option}
            </button>
          ))}
        </div>
      ) : (
        <input
          type="text"
          value={textAnswer}
          onChange={(e) => setTextAnswer(e.target.value)}
          disabled={showResult}
          placeholder="Enter your answer..."
          className="w-full p-4 bg-gray-800 border border-gray-600 rounded-lg text-white focus:border-purple-500 focus:outline-none"
        />
      )}

      {showResult && (
        <div className={`mt-4 p-4 rounded-lg ${
          (question.responseType === 'multiple_choice' && selectedAnswer === question.correctIndex) ||
          (question.responseType === 'free_response' && question.acceptedAnswers.some(a => a.toLowerCase() === textAnswer.trim().toLowerCase()))
            ? 'bg-green-600/20 border border-green-500'
            : 'bg-red-600/20 border border-red-500'
        }`}>
          <p className="text-gray-200">{question.explanation}</p>
        </div>
      )}

      <div className="mt-6 flex justify-end">
        {!showResult ? (
          <button
            onClick={checkAnswer}
            disabled={question.responseType === 'multiple_choice' ? selectedAnswer === null : !textAnswer.trim()}
            className="px-6 py-2 bg-purple-600 hover:bg-purple-500 disabled:bg-gray-600 disabled:cursor-not-allowed rounded-lg font-medium transition-all"
          >
            Check Answer
          </button>
        ) : (
          <button
            onClick={nextQuestion}
            className="px-6 py-2 bg-purple-600 hover:bg-purple-500 rounded-lg font-medium transition-all"
          >
            {currentQuestion + 1 >= questions.length ? 'See Results' : 'Next Question'}
          </button>
        )}
      </div>
    </div>
  );
}
